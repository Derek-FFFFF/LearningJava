## 0x00 并发基础知识

### Java并发原理

    1、Java采取了在顺序型语言的基础上提供对线程的支持，线程机制实在由执行程序表示的单一进程中创建任务
        好处：操作系统的透明性，OSX不支持多任务，如果要支持则需要在Java中添加多线程机制，会破坏Code Once Run Everywhere的原则
    2、并发编程将程序划分多个分离单独运行任务，好像每个任务都有其自己的CPU，底层机制是切分CPU时间   
       
        
### Java线程机制

    线程机制分类？
        抢占式：调度机制会周期性地中断线程，将上下文切换到另一个线程，为每个线程提供时间片
        协作式：任务自动放弃控制，需要开发者手动加入让步语句，就像C++需要自行处理垃圾回收问题
        对比：
            协作式的上下文切换开销低于抢占式，并且理论上同时执行线程数据没有限制

## 0x01 并发解决了什么？

并发解决了`速度`和`设计可管理性`两个问题

为什么并发加快了执行速度？

    1、并发在多CPU中的体现是任务分配到多个CPU中，于是加速了
    
    2、但是并发多用于单线程，为什么？
        虽然单线程并发需要切换上下文增加了开销，但是在任务阻塞的时候，其并发加快了程序运行
        比如多个任务在单CPU中顺序执行，如果任务A卡住了（IO阻塞），那么任务B就无法继续执行下去了
        但是当我们使用并发的时候，这个任务可以暂时停下来，其他任务可以继续执行

## 0x02 基本线程机制

### 基础介绍

run和start方法的区别？
    run方法并没有创建新的线程，而是在当前线程中顺序执行。start方法则在当前线程中创建新线程然后执行run方法的内容
    
Thread对象会被垃圾回收么？
    每个Thread对象都会注册自己，因此有一个对它的引用并且在run执行完毕后并死亡之前，垃圾回收期无法清除它

如何定义任务？
    1、继承Thread类
    2、实现Runnable接口
    3、实现Callable接口
    
如何从任务中获取返回值？
    实现Runnable接口，然后将Runnable实现类传入FutureTask，然后把FutureTask放入Thread执行
    最后通过FutureTask获取返回值
    
什么是后台线程？
    当所有非后台线程结束后，程序就终止了，同时杀死全部后台线程。main就是非后台线程
    
如何统一设置线程？
    方式一、自定义ThreadFactory子类配合Executor，但是每次都要new这个ThreadFactory
    方式二、自定义ThreadPoolExecutor
    
如何统一捕获线程异常？
    方式一：实现Thread.UncaughtExceptionHandler接口，它会对每个Thread附着异常处理器，通过统一设置线程来完成
    
### 方法介绍

yield方法：让出CPU时间片，不会释放锁资源
sleep方法：暂停任务，但是不会让出CPU时间片，不会释放锁资源
setPriority方法：设置优先级，不保证一定优先
setDaemon方法：当前线程成为后台线程，必须在线程启动前设置
join方法：在A线程上调用B线程的join方法，那么A线程会等待B线程执行完毕才继续执行
wait方法：释放锁，前提需要拥有锁
notify方法：唤醒等待锁的线程，前提需要拥有锁
notifyAll方法：

### 库介绍

Executor
    作用：
        1、管理Thread对象，简化并发编程
        2、在客户端和任务执行之间提供间接层
        3、允许管理异步任务的执行，无须显式管理线程的生命周期

## 0x03 共享受限资源

总结规则：

第一点：基本属性的get/set并不会中断
    如boolean status = false，通过set/get方法设置或返回

第二点：竞争条件的消除可以放在共享公共资源中，避免任务之间的依赖

第三点：基本上并发接触线程冲突，多数采用序列化访问共享资源的方案
    采用锁机制产生一种互相排斥的效果，又称为互斥量
        1、Java锁机制中的synchronized是可重入的，通过计时器进行计数获取锁次数
            获取锁+1，释放锁或退出锁方法-1，若计数器为0则释放锁
            
第四点：实现序列化访问的方案有很多，如锁，Java实现锁的方案也有多种，如synchronized关键字和Lock类库
    前者是Java关键字，后者是JavaAPI
    前者不捕获异常，后者可以

          
同步规则：

第一点：如果写某个变量，可能被其他线程读取，或读取上一次被其他线程写的变量，必须同步
    简单说就是当某个变量会被共享，那么必须保证读写该变量的方法都要同步

## 0x04 中断
    
线程状态：
    新建new、就绪Runnable、阻塞Blocked、死亡Dead
    
如何进入阻塞状态？
    - 通过调用sleep方法进入休眠
    - 通过wait挂起线程，直到得到了notify或notifyAll消息，等价于concurrent包中的signal或signalAll
    - 等待某个输入/输出完成
    - 试图在某个对象上调用其同步控制方法，但是对象锁不可用，因为另一个任务已经获取这个锁
    - suspend阻塞、resume唤醒 --> 被弃用，可能导致死锁
    - stop也被弃用，因为它不释放线程获取的的锁
        
中断：如果在run方法中间打断则抛出异常，将通过异常来控制程序流程，必须仔细编写catch子句并正确清除资源
    interrupt方法：将设置线程的中断状态，并复位中断状态
        如果线程被阻塞调用该方法将抛出InterruptException，抛出异常会复位中断状态
        
新concurrent库尽量减少直接对Thread的操作，如果调用shutdownNow，它将发送一个interrupt调用给它启动的所有线程
    通过调用submit并获取返回的Future来中断某个特定任务，在Future#cancel即可调用interrupt停止线程
        
无法中断正在获取synchronized锁或者试图执行I/O操作的线程

## 0x05 线程间协作

wait, notify, notifyAll都是需要获取锁的前提下才能调用，然后针对的也都是该锁的对象

可以通过wait, notify, notifyAll加上状态变量实现消费者-生产者，但是最好是配合阻塞队列实现

## 0x06 死锁

发生死锁条件：
    1、互斥条件，任务使用的资源至少有一个不能共享的
    2、至少有一个任务必须持有一个资源并且正在等待获取一个别的任务持有的资源
    3、资源不能被任务抢占
    4、必须有循环等待
    
## 0x07 Concurrent包

### CountDownLatch

作用：强制某些任务等待其他任务结束之后继续
特征：只能触发一次(计数值无法重置)
流程：
    1、A线程中调用CountDownLatch#await，那么A线程等待CountDownLatch的计数器=0才继续执行
    2、其他线程可以通过CountDownLatch#countDown来对计数器-1

### CyclicBarrier

作用：类似join，所有任务都在某个点等待，直到所有任务都到达该点才继续
特征：类似CountDownLatch，但是可以重置计数器多次使用。支持栅栏动作，在计数器到达0时出发

### DelayQueue

介绍：无界的BlockingQueue，放置实现了Delayed接口的对象，对象只能在到期时才能从队列中取走
作用：
特征：有序、队头对象延迟到期时间最长，没有任何延迟到期则不会有任何头元素（poll就是null，所以不能放入null）

### PriorityBlockingQueue

特征：基础优先级队列，具有可阻塞的读取操作

### ScheduleExecutor
### Semaphore

特征：意味着你有多少个信号量==计数器，每获取一个则-1

### Exchanger

特征：在两个任务之间交换对象的栅栏
场景：一个任务创建对象，但是创建对象代价高昂，另一个任务消费这些对象，通过这种方式，可以有更多的对象在创建时被消费